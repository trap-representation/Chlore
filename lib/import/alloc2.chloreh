$if std_alloc2_guard 0

	set std_alloc2_guard 1

	set EINIT 1    ;Heap isn't initialized.
	set EALIGN 2   ;Cannot align the memory to the requested alignment.
	set EINT 3     ;One of the internal functions that this object uses to allocate memory has encountered an error. In case of this error, the best option is to terminate the program, since it might leave the heap in a corrupted state.
	set EOVF 4     ;The requested amount of memory is more than what's been pre-allocated by the environment for the program.

	/ On success: Signals the enviroment to allocate [top-1] bytes for the heap buffer. The contents of the heap are retained after the reallocation. The heap keeps the alignment that it had before the reallocation.
	  On failure: Returns EINT.
	/

	:hidden$sav_std_alloc2_rlhb (
		$if IS_DYOBJ 1
			over addbp
		$fi
		str0
		pushp std_alloc2_rlhb_f
		$if IS_DYOBJ 1
			addbp
		$fi
		ldnao1c
		& ldr0 & ret
	)

	:sav_std_alloc2_rlhb {
		pushp std_alloc2_rlhb_f
		$if IS_DYOBJ 1
			addbp
		$fi
		ldnao1c
	}

	rbs
	:hidden$std_alloc2_rlhb_f ( dat str "rlhb" )
	rbe

	/ On success: Pushes an (explicit) pointer to a chunk of memory in the heap of size [top-1] bytes, and aligned to a [top] bytes boundary on the [top] of the stack.
	  On failure: Returns one of EINIT, EALIGN, EINT, EOVF.
		      Pushes an unspecified value on the top of the stack.
	/

	:hidden$sav_std_alloc2_aaseg (
		$if IS_DYOBJ 1
			over addbp
		$fi
		str0
		pushp std_alloc2_aaseg_f
		$if IS_DYOBJ 1
			addbp
		$fi
		ldnao1c
		& ldr0 & ret
	)

	:sav_std_alloc2_aaseg {
		pushp std_alloc2_aaseg_f
		$if IS_DYOBJ 1
			addbp
		$fi
		ldnao1c
	}

	rbs
	:hidden$std_alloc2_aaseg_f ( dat str "aaseg" )
	rbe

	/ On success: Pushes an (explicit) pointer to a chunk of memory in the heap of size [top] bytes on the [top] of the stack.
	  On failure: Returns one of EINIT, EINT, EOVF.
		      Pushes an unspecified value on the top of the stack.
	/

	:hidden$sav_std_alloc2_aseg (
		$if IS_DYOBJ 1
			over addbp
		$fi
		str0
		pushp std_alloc2_aseg_f
		$if IS_DYOBJ 1
			addbp
		$fi
		ldnao1c
		& ldr0 & ret
	)

	:sav_std_alloc2_aseg {
		pushp std_alloc2_aseg_f
		$if IS_DYOBJ 1
			addbp
		$fi
		ldnao1c
	}

	rbs
	:hidden$std_alloc2_aseg_f ( dat str "aseg" )
	rbe

	/ On success: Flushes the chunk of memory pointed at by the [top-1] of the stack, and pushes an (explicit) pointer to a chunk of memory of size [top-2] bytes, aligned to a [top] byte boundary, and which & ldr0 & retains the contents of the original chunk, on the [top] of the stack.
	  On failure: Returns one of EINIT, EALIGN, EINT, EOVF.
		      Pushes an unspecified value on the top of the stack.
	/

	:hidden$sav_std_alloc2_arseg (
		$if IS_DYOBJ 1
			over addbp
		$fi
		str0
		pushp std_alloc2_arseg_f
		$if IS_DYOBJ 1
			addbp
		$fi
		ldnao1c
		& ldr0 & ret
	)

	:sav_std_alloc2_arseg {
		pushp std_alloc2_arseg_f
		$if IS_DYOBJ 1
			addbp
		$fi
		ldnao1c
	}

	rbs
	:hidden$std_alloc2_arseg_f ( dat str "arseg" )
	rbe

	/ On success: Flushes the chunk of memory pointed at by the [top] of the stack, and pushes an (explicit) pointer to a chunk of memory of size [top-1] bytes, and which & ldr0 & retains the contents of the original chunk, on the [top] of the stack.
	  On failure: Returns one of EINIT, EINT, EOVF.
		      Pushes an unspecified value on the top of the stack.
	/

	:hidden$sav_std_alloc2_rseg (
		$if IS_DYOBJ 1
			over addbp
		$fi
		str0
		pushp std_alloc2_rseg_f
		$if IS_DYOBJ 1
			addbp
		$fi
		ldnao1c
		& ldr0 & ret
	)

	:sav_std_alloc2_rseg {
		pushp std_alloc2_rseg_f
		$if IS_DYOBJ 1
			addbp
		$fi
		ldnao1c
	}

	rbs
	:hidden$std_alloc2_rseg_f ( dat str "rseg" )
	rbe

	/ On success: Flushes the chunk of memory pointed at by the [top] of the stack. [top] must be an (explicit) pointer & ldr0 & returned by one of `aseg', `aaseg', `rseg', `arseg'.
	  On failure: Returns EINIT.
	/

	:hidden$sav_std_alloc2_flush (
		$if IS_DYOBJ 1
			over addbp
		$fi
		str0
		pushp std_alloc2_flush_f
		$if IS_DYOBJ 1
			addbp
		$fi
		ldnao1c
		& ldr0 & ret
	)

	:sav_std_alloc2_flush {
		pushp std_alloc2_flush_f
		$if IS_DYOBJ 1
			addbp
		$fi
		ldnao1c
	}

	rbs
	:hidden$std_alloc2_flush_f ( dat str "flush" )
	rbe

	/ On success: Frees up all the additional memory allocated by this object.
	  On failure: Returns EINIT.
	/

	:hidden$sav_std_alloc2_close (
		$if IS_DYOBJ 1
			over addbp
		$fi
		str0
		pushp std_alloc2_close_f
		$if IS_DYOBJ 1
			addbp
		$fi
		ldnao1c
		& ldr0 & ret
	)

	:sav_std_alloc2_close {
		pushp std_alloc2_close_f
		$if IS_DYOBJ 1
			addbp
		$fi
		ldnao1c
	}

	rbs
	:hidden$std_alloc2_close_f ( dat str "close" )
	rbe

	/ On success: Dumps the current VM heap state to stdout.
	  On failure: Returns EINIT.
	/

	:hidden$sav_std_alloc2_dump (
		$if IS_DYOBJ 1
			over addbp
		$fi
		str0
		pushp std_alloc2_dump_f
		$if IS_DYOBJ 1
			addbp
		$fi
		ldnao1c
		& ldr0 & ret
	)

	:sav_std_alloc2_dump {
		pushp std_alloc2_dump_f
		$if IS_DYOBJ 1
			addbp
		$fi
		ldnao1c
	}

	rbs
	:hidden$std_alloc2_dump_f ( dat str "dump" )
	rbe

	/ On success: Initializes the heap. Must be called before anything (except `rlhb') in this object is used.
	  On failure: Returns EINT.
	/

	:hidden$sav_std_alloc2_init (
		$if IS_DYOBJ 1
			over addbp
		$fi
		str0
		pushp std_alloc2_init_f
		$if IS_DYOBJ 1
			addbp
		$fi
		ldnao1c
		& ldr0 & ret
	)

	:sav_std_alloc2_init {
		pushp std_alloc2_init_f
		$if IS_DYOBJ 1
			addbp
		$fi
		ldnao1c
	}

	rbs
	:hidden$std_alloc2_init_f ( dat str "init" )
	rbe

	/ Writes the cache hits and misses to stdout. /

	:hidden$sav_std_alloc2_prof (
		$if IS_DYOBJ 1
			over addbp
		$fi
		str0
		pushp std_alloc2_prof_f
		$if IS_DYOBJ 1
			addbp
		$fi
		ldnao1c
		& ldr0 & ret
	)

	:sav_std_alloc2_prof {
		pushp std_alloc2_prof_f
		$if IS_DYOBJ 1
			addbp
		$fi
		ldnao1c
	}

	rbs
	:hidden$std_alloc2_prof_f ( dat str "prof" )
	rbe

	:hidden$sav_std_alloc2 (
		$if IS_DYOBJ 1
			over addbp
		$fi
		str0
		pushp std_alloc2
		$if IS_DYOBJ 1
			addbp
		$fi
		ldnao0c
		& ldr0 & ret
	)

	:sav_std_alloc2 {
		pushp std_alloc2
		$if IS_DYOBJ 1
			addbp
		$fi
		ldnao0c
	}

	rbs
	:hidden$std_alloc2 dat str "./lib/bin/alloc2.so"
	rbe
$fi
