    ;(WIP) Lexer for the Chlore programming language written in Chlore
/   Copyright (C) 2022  Somdipto Chakraborty

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
/


import "./self_hosted/keywords.chloreh"

set BUF_SIZ 4096

:close_resources_and_quit_lexer (
	pushuc 1 pushuc 0 %alloc_close
	pushuc 0 !
	& ldr0 &
	hltr
)

:load_state { & ldr2 & }
:set_state { str2 }

:index_load { dup & ldr3 & addp & ldhc & }
:next_char_index { %++l }
:prev_char_index { %--l }

:token->token_code { }

:token->start_x {
	pushl SIZEOF_UC addp
}

:token->start_y {
	pushl SIZEOF_UC pushl SIZEOF_L addl addp
}

:token->end_x {
	pushl SIZEOF_UC pushl SIZEOF_L pushl SIZEOF_L addl addl addp
}

:token->end_y {
	pushl SIZEOF_UC pushl SIZEOF_L pushl SIZEOF_L pushl SIZEOF_L addl addl addl addp
}

:token->next_token {
	pushl SIZEOF_UC pushl SIZEOF_L pushl SIZEOF_L pushl SIZEOF_L pushl SIZEOF_L addl addl addl addl addp
}

:token->prev_token {
	pushl SIZEOF_UC pushl SIZEOF_L pushl SIZEOF_L pushl SIZEOF_L pushl SIZEOF_L pushl SIZEOF_P addl addl addl addl addl addp
}

:token->fname {
	pushl SIZEOF_UC pushl SIZEOF_L pushl SIZEOF_L pushl SIZEOF_L pushl SIZEOF_L pushl SIZEOF_P pushl SIZEOF_P addl addl addl addl addl addl addp
}

:token->string {
	pushl SIZEOF_UC pushl SIZEOF_L pushl SIZEOF_L pushl SIZEOF_L pushl SIZEOF_L pushl SIZEOF_P pushl SIZEOF_P pushl SIZEOF_P addl addl addl addl addl addl addl addp
}

:token->instr_code {
	pushl SIZEOF_UC pushl SIZEOF_L pushl SIZEOF_L pushl SIZEOF_L pushl SIZEOF_L pushl SIZEOF_P pushl SIZEOF_P pushl SIZEOF_P pushl SIZEOF_P addl addl addl addl addl addl addl addl addp
}

:err_message_failed_read_lexer dat str "MChlore (error): failed to read from file\n"
:failed_read_lexer (
	pushuc 0 pushuc 0 %putstre
	pushp err_message_failed_read_lexer ptr_code
	pushuc 0 !
	pushp close_resources_and_quit_lexer jmp
)

:err_message_failed_alloc_lexer dat str "MChlore (error): failed to allocate memory\n"
:failed_alloc_lexer (
	pushuc 0 pushuc 0 %putstre
	pushp err_message_failed_alloc_lexer ptr_code
	pushuc 0 !
	pushp close_resources_and_quit_lexer jmp
)

:create_token {
	pushuc 1 str4 ;initialize token length

	pushl SIZEOF_UC ;token code
	pushl SIZEOF_L ;starting x position
	pushl SIZEOF_L ;starting y position
	pushl SIZEOF_L ;ending x position
	pushl SIZEOF_L ;ending y position
	pushl SIZEOF_P ;implicit pointer to the next token
	pushl SIZEOF_P ;implicit pointer to the previous token
	pushl SIZEOF_P ;explicit pointer to the file name
	pushl SIZEOF_P ;implicit pointer (in the heap) to the actual string designating the token read
	pushl SIZEOF_UI ;keyword
	;will have to add alignments later, but for now an unaligned access should do it
	addl addl addl addl addl addl addl addl addl
	pushuc 1 !
	& ldr0 & pushp failed_alloc_lexer jnz ;if we fail allocating the memory, close every opened resource, and panic
	ep2ip
}

:init_token {
	& ldr5 & over %token->start_x sthl
	& ldr6 & over %token->start_y sthl
	& ldr5 & over %token->end_x sthl
	& ldr6 & over %token->end_y sthl
}

:init_token_string {
	pushuc 1 pushuc 1 ! ep2ip over %token->string sthp
	pushc '\0' over %token->string & ldhp & sthc
}

:join_token_to_list {
	dup dup dup dup & ldr1 & %token->next_token sthp
	pushp NULL swap %token->next_token sthp
	& ldr1 & swap %token->prev_token sthp
	& ldr1 & %token->fname swap %token->fname sthp
	str1
}

:check_if_at_end_of_buffer {
	dup pushui BUF_SIZ pushp read_another_chunk jeq
	over over
	pushp end_of_buffer jeq
}

:end_of_buffer (
	pop
	pop
	pushp finish_lex jmp
)

:read_another_chunk (
	pop
	pop
	pushp read_chunk jmp
)

:inc_x_pos { & ldr5 & %++l str5 }
:next_line_pos { & ldr6 & %++l str6 pushuc 1 str5 }
:inc_tok_len { & ldr4 & %++l str4 }

:store_and_null_terminate_token->string { & ldr1 & %token->string & ldhp & pushuc 2 & ldr4 & subl addp ;get an implicit pointer to the last character in the string
sthc ;store the character we just read in there

& ldr1 & %token->string & ldhp & pushuc 1 & ldr4 & subl addp ;get an implicit pointer to the last character in the string
pushc '\0' sthc ;store a null terminator there
}

:check_punctuator_and_set_code (
	swap ;top of the stack has the punctuator
	dup pushc '%' pushp is_percent jeq
	dup pushc ':' pushp is_colon jeq
	dup pushc '{' pushp is_openingcurly jeq
	dup pushc '}' pushp is_closingcurly jeq
	dup pushc '(' pushp is_openingbracket jeq
	dup pushc ')' pushp is_closingbracket jeq
	dup pushc '!' pushp is_bang jeq
	dup pushc '~' pushp is_tilde jeq
	dup pushc '&' pushp is_ampersand jeq
	force_panic
	:is_percent
	pop pushuc tk_percent pushp set_code jmp
	:is_colon
	pop pushuc tk_colon pushp set_code jmp
	:is_openingcurly
	pop pushuc tk_opencurly pushp set_code jmp
	:is_closingcurly
	pop pushuc tk_closecurly pushp set_code jmp
	:is_openingbracket
	pop pushuc tk_openbracket pushp set_code jmp
	:is_closingbracket
	pop pushuc tk_closecurly pushp set_code jmp
	:is_ampersand
	pop pushuc tk_ampersand pushp set_code jmp
	:is_bang
	pop pushuc tk_bang pushp set_code jmp
	:is_tilde
	pop pushuc tk_tilde pushp set_code jmp
	:set_code
	& ldr1 & %token->token_code sthuc
	ret
)

:create_and_fill_token_punctuator {
	%create_token
	%init_token
	%join_token_to_list
	%index_load
	pushp check_punctuator_and_set_code call
}

import "./self_hosted/keywords_ops.chloreh"

:lex (
	/NOTE keep `aseg' at the 1st index, `rseg' at the 2nd one, `strcmp' at the 3rd one, and `flush' at the 4th one, unless we're about to return control back to the parser, in which case about anything is fine
	/

	swap ;the top of the stack now has an explicit pointer to the file name that we're currently performing lexical analysis on
	;read the file in chunks, and do lexical analysis on the file
	& ldr0 & ;push the file descriptor of the file we're reading from on the top of the stack
	swap ;get the pointer to the file name back at the top

	pushui BUF_SIZ
	pushuc 1 !
	& ldr0 & panic ;if we fail allocating the memory, panic

	ep2ip str3

	pushuc 0 pushuc 0 %readf

	pushuc 0 str2 ;save the initial state in GPR2
	pushuc 1 str5 ;save the initial x position of the source file in GPR4
	pushuc 1 str6 ;save the inital y position of the source file in GPR5

	%create_token ep2ip dup dup dup dup str7 ;the head of the token list is in GPR7
	pushuc tk_btrans swap %token->token_code sthuc ;beginning of translation unit
	pushp NULL swap %token->next_token sthp ;next token is a pointer to NULL
	pushp NULL swap %token->prev_token sthp ;the previous token is a pointer to NULL
	%token->fname sthp ;save an explicit pointer to the file name we're currently performing lexical analysis on at token->fname

	& ldr7 & str1 ;save the pointer to the head of the list in GPR1

	:read_chunk
	;the top of the stack has the file descriptor
	dup
	& ldr3 & ptr_heap ;explicit pointer to the beginning of the buffer
	pushui BUF_SIZ ;size of the chunk to read
	pushuc 0 !
	& ldr0 & pushi -1 pushp failed_read_lexer jeq ;if read fails, quit
	& ldr0 & pushuc 0 pushp finish_lex jeq
	& ldr0 & ;push the length of the read buffer

	/state 0 -> start of the file || finished reading a token
	 state 1 -> reading a symbol || keyword
	 state 2 -> reading an integer
	 state 3 -> reading a string constant
	 state 4 -> reading single-line comment
	 state 5 -> reading multi-line comment
	 state 6 -> reading a character constant
	 state 7 -> reading an escape sequence (from state 3)
	 state 8 -> reading an escape sequence (from state 6)
	/

	pushuc 0 ;initial offset into the buffer

	:read_token
	/ register def:
	  1 -> implicit pointer to the current token in the tokens list
	  2 -> state of the state machine
	  3 -> implicit pointer to the beginning of the read buffer
	  4 -> length of the token being read
	  5 -> x postion of the line currently being read
	  6 -> y position of the line currently being read
	  7 -> implicit pointer to the head of the tokens list

	  stack def:
	  TOS-2 -> file descriptor
	  TOS-1 -> read buffer size
	  TOS -> offset into the buffer
	/

	%check_if_at_end_of_buffer

	;stack state --> read_length current_offset

	%load_state pushuc 0 pushp state_0_ops jeq
	%load_state pushuc 1 pushp state_1_ops jeq
	%load_state pushuc 2 pushp state_2_ops jeq
	%load_state pushuc 3 pushp state_3_ops jeq
	%load_state pushuc 4 pushp state_4_ops jeq
	%load_state pushuc 5 pushp state_5_ops jeq
	%load_state pushuc 6 pushp state_6_ops jeq
	%load_state pushuc 7 pushp state_7_ops jeq
	%load_state pushuc 8 pushp state_8_ops jeq
	force_panic

	:state_4_ops (
		%index_load pushc '\n' pushp set_state_to_0_and_read_first_char_of_next_line jeq
		pushp read_next_char jmp
	)

	:state_5_ops (
		%index_load pushc '\n' pushp get_next_line_pos_then_read_next_char jeq
		%index_load pushc '/' pushp set_state_to_0_and_read_next_char jeq
		pushp read_next_char jmp
	)

	:check_sequence (
		swap
		%index_load pushc 'a' pushp check_sequence_is_alert jeq
		%index_load pushc 'n' pushp check_sequence_is_newline jeq
		pushp check_sequence_fill_unknown_sequence jmp

		:check_sequence_is_alert
		pushc '\a' pushp fill_token call
		swap
		ret

		:check_sequence_is_newline
		pushc '\n' pushp fill_token call
		swap
		ret

		:check_sequence_fill_unknown_sequence
		%index_load pushp fill_token call
		swap
		ret
	)

	:state_8_ops (
		pushp check_sequence call
		pushp set_state_to_6_and_read_next_char jmp
	)

	:state_6_ops (
		%index_load pushc '\'' pushp set_state_to_0_and_read_next_char jeq
		%index_load pushc '\\' pushp set_state_to_8_and_read_next_char jeq
		pushp fill_token_char jmp
	)

	:state_7_ops (
		pushp check_sequence call
		pushp set_state_to_3_and_read_next_char jmp
	)

	:state_3_ops (
		%index_load pushc '\"' pushp set_state_to_0_and_read_next_char jeq
		%index_load pushc '\\' pushp set_state_to_7_and_read_next_char jeq
		pushp fill_token_char jmp
	)

	:state_2_ops (
		%index_load pushc '0' pushp state_2_maybe_digit jle
		:state_2_ops_continue0
		%index_load pushc 'a' pushp state_2_maybe_lowercase_hex_digit jle
		:state_2_ops_continue1
		%index_load pushc 'A' pushp state_2_maybe_uppercase_hex_digit jle
		:state_2_ops_continue2
		%index_load pushc 'x' pushp state_2_is_hex jeq
		%index_load pushc 'b' pushp state_2_is_hex jeq
		%index_load pushc 'o' pushp state_2_is_hex jeq
		%index_load pushc '-' pushp state_2_is_negative jeq
		%index_load pushc '+' pushp set_state_to_0_and_read_next_char jeq
		pushp set_state_to_0 jmp

		:state_2_maybe_digit
		%index_load pushc '9' pushp fill_token_char jge
		pushp state_2_ops_continue0 jmp

		:state_2_maybe_lowercase_hex_digit
		%index_load pushc 'f' pushp fill_token_char jge
		pushp state_2_ops_continue1 jmp

		:state_2_maybe_uppercase_hex_digit
		%index_load pushc 'F' pushp fill_token_char jge
		pushp state_2_ops_continue2 jmp

		:state_2_is_hex
		pushuc tk_positive_hex & ldr1 & %token->token_code sthuc
		pushp read_next_char jmp

		:state_2_is_bin
		pushuc tk_positive_bin & ldr1 & %token->token_code sthuc
		pushp read_next_char jmp

		:state_2_is_oct
		pushuc tk_positive_oct & ldr1 & %token->token_code sthuc
		pushp read_next_char jmp

		:state_2_is_negative
		& ldr1 &  %token->token_code dup ldhuc pushuc 4 adduc ;adding 4 to the token_code will produce the correct token_code for the negative counterpart
		swap sthuc
		pushp set_state_to_0_and_read_next_char jmp
	)

	:state_1_ops (
		%index_load pushc 'a' pushp state_1_maybe_lowercase jle
		:state_1_ops_continue0
		%index_load pushc 'A' pushp state_1_maybe_uppercase jle
		:state_1_ops_continue1
		%index_load pushc '0' pushp state_1_maybe_integer jle
		:state_1_ops_continue2
		%index_load pushc '`' pushp fill_token_char jeq
		%index_load pushc '~' pushp fill_token_char jeq
		%index_load pushc '@' pushp fill_token_char jeq
		%index_load pushc '#' pushp fill_token_char jeq
		%index_load pushc '$' pushp fill_token_char jeq
		%index_load pushc '^' pushp fill_token_char jeq
		%index_load pushc '*' pushp fill_token_char jeq
		%index_load pushc '-' pushp fill_token_char jeq
		%index_load pushc '_' pushp fill_token_char jeq
		%index_load pushc '.' pushp fill_token_char jeq
		%index_load pushc '=' pushp fill_token_char jeq
		%index_load pushc '+' pushp fill_token_char jeq
		%index_load pushc '\\' pushp fill_token_char jeq
		%index_load pushc '<' pushp fill_token_char jeq
		%index_load pushc '>' pushp fill_token_char jeq
		pushp check_if_instr_or_symbol_then_set_state_to_0 jmp

		:state_1_maybe_lowercase
		%index_load pushc 'z' pushp fill_token_char jge
		pushp state_1_ops_continue0 jmp

		:state_1_maybe_uppercase
		%index_load pushc 'Z' pushp fill_token_char jge
		pushp state_1_ops_continue1 jmp

		:state_1_maybe_integer
		%index_load pushc '9' pushp fill_token_char jge
		pushp state_1_ops_continue2 jmp

		:check_if_instr_or_symbol_then_set_state_to_0
		pushp check_if_instr_or_symbol call
		pushp set_state_to_0 jmp
	)

	:state_0_ops (
		%index_load pushc 'a' pushp state_0_maybe_lowercase jle
		:state_0_ops_continue0
		%index_load pushc 'A' pushp state_0_maybe_uppercase jle
		:state_0_ops_continue1
		%index_load pushc '0' pushp state_0_maybe_integer jle
		:state_0_ops_continue2
		%index_load pushc '`' pushp set_state_to_1 jeq
		%index_load pushc '~' pushp set_state_to_1 jeq
		%index_load pushc '@' pushp set_state_to_1 jeq
		%index_load pushc '#' pushp set_state_to_1 jeq
		%index_load pushc '$' pushp set_state_to_1 jeq
		%index_load pushc '^' pushp set_state_to_1 jeq
		%index_load pushc '*' pushp set_state_to_1 jeq
		%index_load pushc '-' pushp set_state_to_1 jeq
		%index_load pushc '_' pushp set_state_to_1 jeq
		%index_load pushc '.' pushp set_state_to_1 jeq
		%index_load pushc '=' pushp set_state_to_1 jeq
		%index_load pushc '+' pushp set_state_to_1 jeq
		%index_load pushc '\\' pushp set_state_to_1 jeq
		%index_load pushc '>' pushp set_state_to_1 jeq
		%index_load pushc '<' pushp set_state_to_1 jeq
		%index_load pushc '%' pushp state_0_create_and_fill_token_then_read_next_char jeq
		%index_load pushc ';' pushp set_state_to_4_and_read_next_char jeq
		%index_load pushc '/' pushp set_state_to_5_and_read_next_char jeq
		%index_load pushc ':' pushp state_0_create_and_fill_token_then_read_next_char jeq
		%index_load pushc '{' pushp state_0_create_and_fill_token_then_read_next_char jeq
		%index_load pushc '}' pushp state_0_create_and_fill_token_then_read_next_char jeq
		%index_load pushc '(' pushp state_0_create_and_fill_token_then_read_next_char jeq
		%index_load pushc ')' pushp state_0_create_and_fill_token_then_read_next_char jeq
		%index_load pushc '\"' pushp state_0_create_token_then_set_state_to_3 jeq
		%index_load pushc '~' pushp state_0_create_and_fill_token_then_read_next_char jeq
		%index_load pushc '!' pushp state_0_create_and_fill_token_then_read_next_char jeq
		%index_load pushc '\'' pushp state_0_create_token_then_set_state_to_6 jeq
		%index_load pushc '&' pushp state_0_create_and_fill_token_then_read_next_char jeq
		%index_load pushc ' ' pushp read_next_char jeq
		%index_load pushc '\t' pushp read_next_char jeq
		%index_load pushc '\n' pushp get_next_line_pos_then_read_next_char jeq
		force_panic

		:state_0_maybe_lowercase
		%index_load pushc 'z' pushp set_state_to_1 jge
		pushp state_0_ops_continue0 jmp

		:state_0_maybe_uppercase
		%index_load pushc 'Z' pushp set_state_to_1 jge
		pushp state_0_ops_continue1 jmp

		:state_0_maybe_integer
		%index_load pushc '9' pushp set_state_to_2 jge
		pushp state_0_ops_continue2 jmp

		:state_0_create_and_fill_token_then_read_next_char
		%create_and_fill_token_punctuator
		pushp read_next_char jmp

		:state_0_create_token_then_set_state_to_3
		%next_char_index
		%inc_x_pos
		%create_token
		%init_token
		%init_token_string
		%join_token_to_list
		pushuc tk_char_seq_string & ldr1 & %token->token_code sthuc
		pushp set_state_to_3 jmp

		:state_0_create_token_then_set_state_to_6
		%next_char_index
		%inc_x_pos
		%create_token
		%init_token
		%init_token_string
		%join_token_to_list
		pushuc tk_char_seq_char & ldr1 & %token->token_code sthuc
		pushp set_state_to_6 jmp
	)

	:set_state_to_1 (
		pushuc 1 str2
		%create_token
		%init_token
		%init_token_string
		%join_token_to_list
		pushuc tk_symbol & ldr1 & %token->token_code sthuc
		pushp read_token jmp
	)

	:set_state_to_2 (
		pushuc 2 str2
		%create_token
		%init_token
		%init_token_string
		%join_token_to_list
		pushuc tk_positive_dec & ldr1 & %token->token_code sthuc
		pushp read_token jmp
	)

	:set_state_to_0 (
		pushuc 0 str2
		pushp read_token jmp
	)

	:set_state_to_3 (
		pushuc 3 str2
		pushp read_token jmp
	)

	:set_state_to_3_and_read_next_char (
		pushuc 3 str2
		pushp read_next_char jmp
	)

	:set_state_to_6 (
		pushuc 6 str2
		pushp read_token jmp
	)

	:set_state_to_6_and_read_next_char (
		pushuc 6 str2
		pushp read_next_char jmp
	)

	:set_state_to_0_and_read_first_char_of_next_line (
		pushuc 0 str2
		pushp get_next_line_pos_then_read_next_char jmp
	)

	:set_state_to_0_and_read_next_char (
		pushuc 0 str2
		pushp read_next_char jmp
	)

	:set_state_to_4_and_read_next_char (
		pushuc 4 str2
		pushp read_next_char jmp
	)

	:set_state_to_5_and_read_next_char (
		pushuc 5 str2
		pushp read_next_char jmp
	)

	:set_state_to_7_and_read_next_char (
		pushuc 7 str2
		pushp read_next_char jmp
	)

	:set_state_to_8_and_read_next_char (
		pushuc 8 str2
		pushp read_next_char jmp
	)

	:read_next_char (
		%next_char_index
		%inc_x_pos
		pushp read_token jmp
	)

	:get_next_line_pos_then_read_next_char (
		%next_char_index
		%next_line_pos
		pushp read_token jmp
	)

	:fill_token_char (
		%index_load
		pushp fill_token call
		pushp read_next_char jmp
	)

	:fill_token (
		%inc_tok_len
		& ldr5 & ldr1 & %token->end_x sthl ;update the end_x position
		& ldr6 & ldr1 & %token->end_y sthl ;update the end_y position
		& ldr4 & ldr1 & %token->string & ldhp & ptr_heap
		pushuc 2 ! ;reallocate token->string
		& ldr0 & pushp failed_alloc_lexer jnz ;if we fail allocating the memory, close every opened resource, and panic
		ep2ip
		& ldr1 & %token->string sthp
		swap ;the top of the stack has the character that we want to store
		%store_and_null_terminate_token->string
		ret
	)

	:finish_lex
	swap
	ret
)

:print_tokens (
	pushuc 0 pushuc 0 %putstr
	pushuc 0 pushuc 3 %putchar
	pushuc 0 pushuc 4 %putui
	pushuc 0 pushuc 5 %putl
	pushuc 0 pushuc 6 %putstr
	pushuc 0 pushuc 7 %putuc
	& ldr7 & %token->next_token & ldhp & ;get the token next to the head of the list

	:print_tokens_continue0
	dup %token->start_y & ldhl & pushuc 5 !
	pushc ':' pushuc 3 !
	dup %token->start_x & ldhl & pushuc 5 !
	pushc ':' pushuc 3 !
	pushc ':' pushuc 3 !
	dup %token->end_y & ldhl & pushuc 5 !
	pushc ':' pushuc 3 !
	dup %token->end_x & ldhl & pushuc 5 !
	pushc ' ' pushuc 3 !
	dup %token->token_code & ldhuc & pushuc 4 !
	dup %token->token_code & ldhuc & pushuc tk_char_seq_string pushp print_tokens_printstr jeq
	dup %token->token_code & ldhuc & pushuc tk_char_seq_char pushp print_tokens_printstr jeq
	dup %token->token_code & ldhuc & pushuc tk_symbol pushp print_tokens_printstr jeq
	dup %token->token_code & ldhuc & pushuc tk_positive_dec pushp print_tokens_maybe_integer jle
	dup %token->token_code & ldhuc & pushuc tk_instr pushp print_tokens_instr jeq

	:print_tokens_continue1
	dup %token->next_token & ldhp & pushp NULL pushp print_tokens_break jeq
	pushc '\n' pushuc 3 !
	%token->next_token & ldhp &
	pushp print_tokens_continue0 jmp

	:print_tokens_break
	pop
	ret

	:print_tokens_maybe_integer
	dup %token->token_code & ldhuc & pushuc tk_negative_bin pushp print_tokens_printstr jge
	pushp print_tokens_continue1 jmp

	:print_tokens_printstr
	pushuc ' ' pushuc 3 !
	dup %token->string & ldhp & ptr_heap pushuc 6 !
	pushp print_tokens_continue1 jmp

	:print_tokens_instr
	pushuc ' ' pushuc 3 !
	dup %token->instr_code & ldhui & pushuc 7 !
	pushp print_tokens_continue1 jmp
)

